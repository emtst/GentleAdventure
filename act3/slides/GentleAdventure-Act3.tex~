%\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass[xcolor={dvipsnames}]{beamer}

\usepackage[utf8]{inputenc}
%\usepackage[british]{babel}
%\usepackage{xcolor}
%\usepackage{tikz}
\usepackage{tkz-euclide}
\usepackage[normalem]{ulem}
%\usepackage{amssymb}
%\usepackage{pifont}
%\usepackage{graphicx}
%\usepackage{minted}
%\usepackage{diagrams}
\usepackage[all]{xy}

\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}

\title{Towards Formalising Trace Equivalence}
\subtitle{for Global and Local Types}

%\author{Lorenzo Gheri}
%\institute{\normalsize Middlesex University, London}
%\date{27th September 2017}


\author{David Castro-Perez \and Francisco Ferreira \and \underline{Lorenzo Gheri} \and Nobuko Yoshida}

\institute{Imperial College London}
%\textsuperscript{1}Vrije Universiteit Amsterdam, Netherlands \and
%\textsuperscript{2}Max-Planck-Institut f\"ur Informatik, Germany\and
%\textsuperscript{3}Middlesex University London, UK
%\and 
%\textsuperscript{4}MAIS, TU Darmstadt, Germany \and
%\textsuperscript{5}Institute of Mathematics Simion Stoilow of the Romanian Academy, Romania \and
%\textsuperscript{6}ETH~Z\"urich, Switzerland
%%Institute of Mathematics Simion Stoilow of the Romanian Academy, Bucharest, Romania
%}
%\date{Inria, CRI Rennes - Bretagne Atlantique\\ April 20, 2018}
\date{Verification of Session Types Workshop - 4th June 2020}

%\date[ITP 2017] % (optional)
%{ITP 2017\\
%Brasilia, 
%26th-29th September 2017}


\input{macros}


\definecolor{MyGreen}{RGB}
%{34, 139, 34}
%{85, 107, 47}
%{19, 136, 8}
%{86, 130, 3}
{0,89,52}
\definecolor{MyPink}{RGB}
%{191, 118, 109} Isa
%{191, 123, 115}
%{191, 139, 109}
%{183, 139, 134} %guasi
%{191, 150, 145} %guasiguasi
{191, 163, 160}
%{252, 189, 236}
\definecolor{LightGray}{RGB}{211, 211, 211}
\definecolor{DarkGray}{RGB}{169, 169, 169}
%\newcommand\coll[1]{{\colorbox{light-gray}{$#1$}}}
\newcommand\coll[1]{\mbox{\colorbox{LightGray}{$\!#1\!$}}}
%\usecolortheme[named=MyGreen]{structure}
\usetheme{Copenhagen}
%\usecolortheme{seagull}
%\usecolortheme[named=green]{structure}
\setbeamercovered{invisible}
\setbeamercolor{structure}{fg=MyGreen}
%\setbeamercolor{title}{fg=MyPink}
%\setbeamercolor{frametitle}{fg=MyPink}
%\setbeamercolor{block title}{fg=MyPink}
%\setbeamercolor{titlelike}{fg=MyPink}
%\setbeamercolor{item projected}{fg=MyPink}
%\setbeamercolor{title in sidebar}{fg=MyPink}
\setbeamercolor{block body}{bg=MyPink}

%\include{comsdefs}
%\newcommand{\Iff}{\textsf{Iff}}
%\newcommand{\AND}{\mbox{\rm\textsf{AND}}}
%\newcommand{\ALL}{\mbox{\rm\textsf{ALL}}}
\newcommand{\gF}{\mbox{\rm\textsf{gF}}}
\newcommand{\gP}{\mbox{\rm\textsf{gP}}}
\newcommand{\gAND}{\mbox{\rm\textsf{gAND}}}
\newcommand{\gNOT}{\mbox{\rm\textsf{gNOT}}}
\newcommand{\gALL}{\mbox{\rm\textsf{gALL}}}
\newcommand{\gEQ}{\mbox{\rm\textsf{gEQ}}}
%\newcommand{\gt}{\mbox{gt}}
\newcommand{\gt}{\tilde{t}}
%\newcommand{\gphi}{\mathit{g\varphi}}
\newcommand{\gphi}{\tilde{\varphi}}
\newcommand{\formula}{\mbox{\bf formula}}
%\newcommand{\cmark}{\ding{51}}
%\newcommand{\xmark}{\ding{55}}
\setbeamertemplate{navigation symbols}{}
\newcommand{\Sym}{{\mathit{Sym}}}

\newcommand{\DD}{{\TC{D}}}
%\renewcommand{\DDD}{\mathcal{D}}
\newcommand{\DVars}{\mathsf{{DFVars}}}
\newcommand{\Dmap}{\mathsf{{Dmap}}}
\newcommand{\Pmap}{\mathsf{{Pmap}}}
\newcommand{\UUU}{\mathcal{U}}
\newcommand{\PPP}{\mathcal{P}}
\newcommand{\UVars}{\mathsf{{UFVars}}}
\newcommand{\Umap}{\mathsf{{Umap}}}
\newcommand{\Uctor}{\mathsf{{Uctor}}}
\newcommand{\Udtor}{\mathsf{{Udtor}}}
\newcommand{\pu}{\mathit{pu}}

\definecolor{mine}{RGB}{10,127,87}


\newcommand{\high}[1]{\textcolor{blue}{#1}}
\newcommand{\bad}[1]{\textcolor{red}{#1}}
\newcommand{\gray}[1]{\textcolor{gray}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\green}[1]{{\textcolor{mine}{#1}}}
\newcommand{\black}[1]{\textcolor{black}{#1}}
\newcommand{\brown}[1]{\textcolor{brown}{#1}}
\newcommand{\white}[1]{\textcolor{white}{#1}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\typeT}{{\TC{Type}}}
\newcommand{\pat}{{\TC{Pattern}}}
\newcommand{\brownNR}[2]{#1^{\brown{@ #2}}}
\newcommand{\fpfunT}{{\TC{FinPFunc}}}
%\newcommand{\recordt}{{\TC{Record}}}
%\newcommand{\typet}{{\TC{Type}}}
\newcommand{\termt}{{\TC{Term}}}

\newcommand{\Ap}{\mathsf{Ap}}
\newcommand{\Trm}{\mathsf{Trm}}
\newcommand{\Vari}{\mathsf{Vr}}
%\newcommand{\Lam}{\mathsf{{Lm}}}
%\newcommand{\Lm}{\mathsf{{Lm}}}
\newcommand{\Vr}{\mathsf{{Vr}}}
%\newcommand{\Var}{\mathsf{{Var}}} 
\newcommand{\sw}{\!\wedge\!}
\newcommand{\Perm}{\mathsf{{Perm}}}
\newcommand{\Bool}{{\TC Bool}}
\newcommand{\ddepth}{{{\mathsf{depth}}}}
\newcommand{\purple}[1]{{\color{purple} #1}}
\newcommand{\orange}[1]{{\color{orange} #1}}
\newcommand{\len}{\mathsf{{len}}}
%\renewcommand{\Set}{\TC{{Set}}}


\begin{document}

\begin{frame}
	\maketitle
%	\begin{flushright}
%	\begin{tiny}
%	I got the poison, I got the remedy...
%	\end{tiny}
%	\end{flushright}
\end{frame}
%
%




\begin{frame}[fragile]{Certifying the Semantics of Communication}


This work is part of a bigger project for certifying, and reasoning about, programs in distributed systems.

\[
\begin{tikzcd}
\G\arrow[rr, "\rho"]\arrow[dd, "{\pmb \upharpoonright}"]& &\coG\arrow[rr, "\text{LTS}"]\arrow[dd, "{\pmb \upharpoonright}^{\sf c}" black] & & \text{Traces}\arrow[dd, leftrightarrow, "="]\\
& &\\
\lT\arrow[rr, "\rho_L"]& &\colT\arrow[rr, "\text{LTS}"]& &\text{Traces}
\end{tikzcd}
\]

%note: maybe bigger diagram, maybe in the conclusion and future work
\begin{footnotesize}


\begin{itemize}
	\item We formalize the meta-theory of multiparty session types\footnote{\tiny Deni{\'e}lou P.-M., Yoshida N. (2013) Multiparty Compatibility in Communicating Automata: Characterisation and Synthesis of Global Session Types. ICALP 2013.}.
	\item We use the Coq\footnote{\tiny https://coq.inria.fr/} Proof Assistant.
\end{itemize}

\end{footnotesize}

\end{frame}



\begin{frame}{Global and Local Types}
\begin{small}
Inductively defined by the following syntaxes:
  \[
  \begin{array}{lllr}
 \G & ::=& \gend & \text{end type}\\
   &\SEP &\gX & \text{variable}\\
   &\SEP &\grec \gX \G & \text{recursion}\\
  &\SEP &\msgi \p\q \ell {S} {\G} & \text{message}
  \end{array}
  \]
  
  \[
  \begin{array}{lllr}
  \lT & ::= & \lend & \text{end type}\\
  &\SEP &\lX & \text{variable}\\
  &\SEP &\lrec \lX \lT & \text{recursion}\\
  &\SEP & \lsend \q \ell {S} {\lT} & \text{send type}\\
  &\SEP &\lrecv \p \ell {S} {\lT} & \text{receive type}
  \end{array}
  \]

Types are assumed \emph{closed} (no free variables) and recursion variables are always assumed \emph{guarded} in types (namely types like $\dgt{\mu \gX.\gX}$ are not allowed).
\end{small}

\end{frame}






\begin{frame}{Projection}

\begin{footnotesize}


 Projection Rules: \\
 \ \\

  \begin{tabular}{@{\hskip 0mm}l@{\hskip 2mm}l@{\hskip 3mm}r}
    $\bullet$ &%
    %$\pr \not\in \participant{\G}$ implies $\projt{\G} \pr = \tend$;%
    $\projt{\gend} \pr = \lend$;
    & \rulename{proj-end}
    \\[2mm]%
    $\bullet$ & $\projt{\gX}{\pr}=\lX$; & \rulename{proj-var}
    \\[2mm]%
    $\bullet$ & $\projt{(\grec \gX \G)}{\pr}=\lrec \lX {} (\projt{\G}{\pr})$ & \rulename{proj-rec} %if $\pr\in\participant{\G}$; 		& \rulename{proj-rec-1}
    \\[2mm]%
    $\bullet$ &%
    $\pr=\p$ implies 
    $\projt{\msgi \p\q \ell {S} {\G}} \pr=\lsendni \q \ell {S} { {\color{black}\projt{\G_{\dgt i}} \pr} }$;
    & \rulename{proj-send}
  	\\[2mm]%
    $\bullet$ &%
    $\pr=\q$ implies 
    $\projt{\msgi \p\q \ell {S} {\G}} \pr=\lrecvni \p \ell {S} { {\color{black}\projt{\G_{\dgt i}} \pr} } $;
    & \rulename{proj-recv}
    \\[2mm]%
    $\bullet$ &%
    $\pr\neq \p$, $\pr \neq \q$ and, for all $\ i,j\in I$, $\projt{\G_{\dgt{i}}}\pr=\projt{\G_{\dgt{j}}}\pr$; implies &\\
    & $\projt{\msgi \p\q \ell {S} {\G}} \pr= \projt {\G_{\dgt 1}} \pr$;
    &  \rulename{proj-cont}
    \\[2mm]%
    $\bullet$ & undefined otherwise. &
  \end{tabular}
  
%  Projection is the core idea of multiparty session types: the local types of single processes are disciplined by a single global type, of which they are projections onto participants.

\end{footnotesize}
\end{frame}


\begin{frame}{Warm-Up!}
\begin{footnotesize}
A global type for a simple protocol:      
\[
\dgt{\G=\msg \p \q \ell(S).\msg \q \pr \ell'(S'). \gend }
\]
and its projection on participant $\q$:
\[
\projt \G \q = \dlt{\lrcv \p \ell(S).\lsnd \pr \ell'(S'). \lend}
\]
\ \\
\visible<2->{
%\textbf{Quiz!}\\
%}
%\visible<3->{
Do these global types have well defined projections?
\[
\begin{array}{lll}
\msg \p \q \dgt{\{}&\dgt{\ell_1(\text{oranges}).\gend,}&\\
		     &\dgt{\ell_2(\text{bananas}).\msg \q \p \ell_3(\text{pears}).\gend \}}& \visible<3->{\textbf{YES!}}
		     \vspace{0.3cm}\\
		     
\msg \p \q \dgt{\{}&\dgt{\ell_1(\text{oranges}).\gend,}&\\
		     &\dgt{\ell_2(\text{bananas}).\msg \q \pr \ell_3(\text{pears}).\gend \}}&\visible<3->{\textbf{NO!}}
		     \vspace{0.3cm}\\
		     
\msg \p \q \dgt{\{}
			 &\dgt{\ell_1(\text{oranges}).\msg \p \pr \ell_3(\text{pears}).\gend,}&\\
		     &\dgt{\ell_2(\text{bananas}).\msg \q \pr \ell_3(\text{pears}).\gend \}}&\visible<3->{\textbf{NO!}}
		     \vspace{0.3cm}\\			     

\msg \p \q \dgt{\{}
			 &\dgt{\ell_1(\text{oranges}).\msg \q \pr \ell_3(\text{pears}).\gend,}&\\
		     &\dgt{\ell_2(\text{bananas}).\msg \q \pr \ell_3(\text{pears}).\gend \}}&\visible<3->{\textbf{YES!}}
	     
\end{array}
\]




}
%a —> b {orange:end, banana:b—>a:end}
%a —>b {orange:end, banana: b—> c:end}
%a —> b:{orange:a—>c:end, banana: b—>c:end}
%a —> b:{orange:b—>c:end, banana: b—>c:end}

\end{footnotesize}


\end{frame}


\begin{frame}[fragile]{Certifying the Semantics of Communication}

\[
\begin{tikzcd}
\G\arrow[rr, "\rho"]\arrow[dd, "{\pmb \upharpoonright}"]& &\coG\arrow[rr, "\text{LTS}"]\arrow[dd, "{\pmb \upharpoonright}^{\sf c}" black] & & \text{Traces}\arrow[dd, leftrightarrow, "="]\\
& &\\
\lT\arrow[rr, "\rho_L"]& &\colT\arrow[rr, "\text{LTS}"]& &\text{Traces}
\end{tikzcd}
\]


\begin{itemize}
\item Multiparty Session Types \checkmark
\item Coinductive Trees (equi-recursive point of view)
\item Semantics by Traces
\end{itemize}

\end{frame}

\begin{frame}{An Equi-Recursive Viewpoint}
\begin{footnotesize}
``We adopt the \emph{equi-recursive viewpoint}, i.e., we identify $\dgt{\mu\gX.\G}$ and $\dgt{\G \{ \gmu\gX.\G / \gX \}}$.''\\ \ \\

\visible<2->{Example:\\
$\dgt{\gmu \gX. \msg \p \q \ell(S). \gX}$ is ``the same as'' $\dgt{\msg \p \q \ell(S). (\gmu \gX. \msg \p \q \ell(S). \gX)}$,\\}
\visible<3->{which is ``the same as'' $\dgt{\msg \p \q \ell(S).\msg \p \q \ell(S).(\gmu \gX. \msg \p \q\ell(S). \gX)}$,\\}
\visible<4->{which is ``the same as'' $\dgt{\msg \p \q \ell(S).\msg \p \q \ell(S).\msg \p \q \ell(S).(\gmu \gX. \msg \p \q \ell(S).\gX)}$,\\}
\visible<5->{which is ``the same as'' $\dgt{\msg \p \q \ell(S).\msg \p \q \ell(S).\msg \p \q \ell(S).\msg \p \q (\gmu \gX. \msg \p \q \ell(S).\gX)}$,\\}
\visible<6->{$\dots$\\
\ \\
with a coinductive unrolling process!}

\end{footnotesize}
\end{frame}




\begin{frame}{Coinductive Asynchronous Trees}
\begin{footnotesize}
Global Trees:\\
    \[
	\begin{array}{lllr}
    \coG & ::=  & \cogend & \text{end type}\\
         & \SEP & \comsgni \p\q \ell {S} {\coG} & \text{message send}\\
         & \SEP & \comsgsi  \p\q {\ell_{\bar{\imath}}} \ell {S} {\coG} & \text{message receive} 
	\end{array}  	
  	\]


\alt<2->
{
Local Trees:\\
      \[
      \begin{array}{lllr}
 	  \colT & ::=  &  \colend & \text{end type}\\
        & \SEP & \colsend \p \ell {S} {\colT} & \text{send type}\\
      & \SEP & \colrecv \q \ell {S} {\colT} & \text{receive type}
      \end{array}
  \]
}
{
Coinductive unrolling $\_\rho\_$:\\
  \[
  \begin{array}{c}
  \Dfrac{ }{\gunroll \gend \cogend}\ \ \ \ \ \ \ \ 
  \Dfrac{\gunroll {\dgt{\G \{ \gmu\gX.\G / \gX \}}} \coG}{\gunroll{\grec \gX \G} \coG}\\
  \vspace{0.2cm} \\
  \Dfrac{\forall i\in I. \gunroll {\dgt{\G_i}} {\dcog{\coG_i}} }{\gunroll{\msgi \p\q \ell {S} {\G}}{\comsgni \p\q \ell {S} {\coG}} }
  \end{array}
  \]
}


\end{footnotesize}
\end{frame}

%\begin{frame}{Tree Projection}
%\begin{scriptsize}
%  \[
%  \begin{array}{cr}
%  \Dfrac{ }{\coproj {\pr} {\cogend}  {\colend}} & \rulename{co-proj-end}\\
%  \vspace*{0.1cm}\\
% \Dfrac{\forall i\in I. \coproj {\p} {\coG_{\dcog i}} {\colT_{\dcol i}} }
% 			{\coproj {\p} {\comsgni \p\q \ell {S} {\coG}} {\colsend \p \ell {S} {\colT}}} 
% 			&  \rulename{co-proj-send-1}\\
%  \vspace*{0.1cm}\\
% \Dfrac{\forall i\in I. \coproj {\p} {\coG_{\dcog i}} {\colT_{\dcol i}} } 	{	
% 		\coproj {\p} {\comsgsi  \p\q {\ell_{\bar{\imath}}} \ell {S} {\coG} }  
% 		{\colT_{\dcol \ell_{\dcol{\bar{\imath}}} } } }
% 			&  \rulename{co-proj-send-2}\\
% \vspace*{0.1cm}\\
% \Dfrac{\forall i\in I. \coproj {\q} {\coG_{\dcog i}} {\colT_{\dcol i}} } 	{	
% 		\coproj {\q} { \comsgni \p\q \ell {S} {\coG}} {\colrecv \p \ell {S} {\colT} } }  
% 			&  \rulename{co-proj-recv-1}\\
%   \vspace*{0.1cm}\\
% \Dfrac{\forall i\in I. \coproj {\q} {\coG_{\dcog i}} {\colT_{\dcol i}} } 	{	
% 		\coproj {\q} {\comsgsi  \p\q {\ell_{\bar{\imath}}} \ell {S} {\coG} }  
% 		{\colrecv \p \ell {S} {\colT} } } 
% 			&  \rulename{co-proj-recv-2}\\
% 	   \vspace*{0.1cm}\\
% \Dfrac{\pr\neq\p\ \ \ \ \pr\neq\q\ \ \ \ \ \ \ \ 
% \forall i\in I. \coproj {\pr} {\coG_{\dcog i}} {\colT_{\dcol i}}\ \ \ \ \ \ \ \ 
% \forall i,j\in I.  \colT_{\dcol i}=\colT_{\dcol j}
% } 	{	
% 		\coproj {\pr} { \comsgni \p\q \ell {S} {\coG} } {\colT_{\dcol 1} } 
% 		} 
% 			&  \rulename{co-proj-cont}
%  \end{array}
%  \]
%\end{scriptsize}  
%\end{frame}



\begin{frame}[fragile]{Certifying the Semantics of Communication}

\[
\begin{tikzcd}
\G\arrow[rr, "\rho"]\arrow[dd, "{\pmb \upharpoonright}"]& &\coG\arrow[rr, "\text{LTS}"]\arrow[dd, "{\pmb \upharpoonright}^{\sf c}" black] & & \text{Traces}\arrow[dd, leftrightarrow, "="]\\
& &\\
\lT\arrow[rr, "\rho_L"]& &\colT\arrow[rr, "\text{LTS}"]& &\text{Traces}
\end{tikzcd}
\]

\begin{itemize}
\item Multiparty Session Types \checkmark
\item Coinductive Trees (equi-recursive point of view) \checkmark
\item Semantics by Traces
\end{itemize}

\end{frame}




\begin{frame}{Asynchronous Semantics}
$\p$ sends a message to $\q$ with label $\ell$:
\[
\dcog {\comsgn \p \q \ell(S). \coG} 
\visible<2->{\stepa \ell \dcog {\comsgs \p \q \ell\ell(S). \coG}} \visible<3->{\stepa \ell \coG}
\]
We keep track of this communication with a queue:
\[
\epsilon\visible<2->{\enq[(\ell,S)]}\visible<3->{\deq\epsilon}
\]
\visible<4->{We have such a queue for each pair of participants.}
\end{frame}

\begin{frame}{Queues for Asynchronous Local Coordination}
\begin{footnotesize}
$\p$ sends and $\q$ receive:
\[
\begin{tikzcd}[ampersand replacement=\&]
\colsnd \q \dcol{\ell(S).} \colT \arrow[rr, "\text{step}"]\& \&\colT\&\&\\
Q(\p,\q)=\epsilon\arrow[rr,"\text{enqueue}"] \& \& Q(\p,\q)=[(\ell , S)]\arrow[rr,"\text{dequeue}"] \& \& Q(\p,\q)=\epsilon\\
\& \& \colrcv \p  \dcol{\ell(S).} \colT{\color{dkolive}'}  \arrow[rr, "\text{step}"]\& \& \colT{\color{dkolive}'} 
\end{tikzcd}
\]

\begin{block}{Queue Environments}
	A \emph{queue environment} is a finitely supported function $Q$ of type $\role \times \role \rightarrow \mathcal{W}$, where $\mathcal{W}$ is the set of finite words $w$ (\emph{queues}) on the alphabet $\code{labels}\times\code{sorts}$.%, e.g.,

%	\begin{itemize}
%	\item $w=[(\ell_1,S_1)(\ell_2,S_2)\dots(\ell_k,S_k)]$ is a queue;
%	\item $Q$ such that $Q(\p,\q)=w$ and $Q(\pr_1,\pr_2)=\epsilon$ all $(\pr_1,\pr_2)\neq(\p,\q)$ is a queue environment.
%	\end{itemize}
\end{block}

\end{footnotesize}
\end{frame}

\begin{frame}[fragile]{Global and Local Steps}
\begin{footnotesize}

$\p$ sends:
\[
\begin{tikzcd}[ampersand replacement=\&]
\comsgn \p\q \dcog{\ell (S).} \coG \arrow[rr, "\text{step}_1 "]\arrow[dd,"\upharpoonright_{\p}"]
\& \&
\comsgs \p\q \ell \dcog{\ell (S).} {\coG}\arrow[rr, "\text{step}_2 "]\arrow[rrdd, "\upharpoonright_{\p}"]
\& \&
\coG\arrow[dd, "\upharpoonright_{\p}"] \\
\& \& \& \&\\
\colsnd \q \dcol{\ell (S).} \colT \arrow[rrrr, "\text{step}_1"]\& \& \& \&\colT
\end{tikzcd}
\]
\ \\
\ \\
\ \\
\visible<2->{
$\q$ receives:
\[
\begin{tikzcd}[ampersand replacement=\&]
\comsgn \p\q \dcog{\ell (S).} {\coG} \arrow[rr, "\text{step}_1 "]\arrow[dd,"\upharpoonright_{\q}"]
\& \&
\comsgs \p\q {\ell} \dcog{\ell (S).} {\coG}\arrow[rr, "\text{step}_2 "]\arrow[lldd, "\upharpoonright_{\q}"]
\& \&
\coG\arrow[dd, "\upharpoonright_{\q}"] \\
\& \& \& \&\\
\colrcv \p \dcol{\ell (S).} \colT\dcol{'} \arrow[rrrr, "\text{step}_2"]\& \& \& \&\colT\dcol{'}
\end{tikzcd}
\]
}
\end{footnotesize}

\end{frame}


\begin{frame}[fragile]{``Local'' Environments}
\begin{small}

%\begin{block}{Queue Environments}
%	A \emph{queue environment} is a finitely supported function $Q$ of type $\role \times \role \rightarrow \mathcal{W}$, where $\mathcal{W}$ is the set of finite words $w$ (\emph{queues}) on the alphabet $\code{labels}\times\code{sorts}$, e.g.,
%
%	\begin{itemize}
%	\item $w=[(\ell_1,S_1)(\ell_2,S_2)\dots(\ell_k,S_k)]$ is a queue;
%	\item $Q$ such that $Q(\p,\q)=w$ and $Q(\pr_1,\pr_2)=\epsilon$ all $(\pr_1,\pr_2)\neq(\p,\q)$ is a queue environment.
%	\end{itemize}
%\end{block}

%\visible<2->{
We %also 
want to consider altogether the different local types involved in the communication.
%\ \\
\begin{block}{Environments for Local Types}
	An \emph{environment for local types} is a finitely supported function $\dcol{E}$ of type $\role\rightarrow\colty$.
\end{block}
%}
%\visible<3->{
\ \\
\visible<2->{Why?!}
\\ \ \\
\visible<3->{It will be $\dcol{E(\p)=\colT_{\p}}$, where $\coG\upharpoonright_{\p}^{\sf c}\dcol{\colT_{\p}}$.}
%}

\end{small}



\end{frame}

\begin{frame}{One-Shot Projection}
\begin{small}
%Queue environments as projections of global trees.
%\begin{itemize}
%\item $\comsgni \p\q \ell {S} {\coG} \upharpoonright^{\sf q} Q$ where $Q(\p,\q)=\epsilon$
%\item<2-> $\comsgsi \p\q {\ell_{\bar{\imath}}} \ell {S} {\coG}\upharpoonright^{\sf q} Q[(\p,\q)%\leftarrow[(\ell_{\bar{\imath}},S_{\bar{\imath}})]]$
%\end{itemize}


%\visible<3->{
We get the one-shot projection of a global type both on environments of local types and on queue environments.
\[
\begin{tikzcd}[ampersand replacement=\&]
\&\coG\arrow[dl,"{\pmb\upharpoonright}^{\sf c}"]\arrow[dr,"{\pmb\upharpoonright}^{\sf q}"']\&\&\&\coG\arrow[d, "{\pmb\upharpoonright}\!{\pmb\upharpoonright}"]\\
\dcol{E}\& \&Q\&\&(\dcol{E},Q)
\end{tikzcd}
\]
%}

\end{small}
\end{frame}



\begin{frame}{Step Results}
\begin{theorem}[Step Soundness]
If $\coG\upharpoonright\!\upharpoonright({\color{dkolive}E},Q)$ and $\coG\step\coG{\color{pine}'}$, then there exist ${\color{dkolive}E'}$ and $Q'$, such that $\coG{\color{pine}'}\upharpoonright\!\upharpoonright({\color{dkolive}E'},Q')$ and $({\color{dkolive}E},Q)\step({\color{dkolive}E'},Q')$.
\end{theorem}

\begin{theorem}[Step Completeness]
If $\coG\upharpoonright\!\upharpoonright({\color{dkolive}E},Q)$ and $({\color{dkolive}E},Q)\step({\color{dkolive}E'},Q')$, then there exists $\coG{\color{pine}'}$, such that  $\coG{\color{pine}'}\upharpoonright\!\upharpoonright({\color{dkolive}E'},Q')$ and $\coG\step\coG{\color{pine}'}$.
\end{theorem}
\end{frame}




\begin{frame}{Labelled Transition System}
\begin{small}

Keeping track of messages...
\begin{block}{Actions}
	An \emph{action} $a$ is an object of the shape:
	\begin{itemize}
	\item either $\p\q ! (\ell,S)$ (send action),
	\item or $\p\q ? (\ell,S)$ (receive action).
	\end{itemize}
\end{block}


\begin{block}{Traces}
	A \emph{trace} $t$ is a coinductive, possibly infinite, stream of actions:
	\begin{itemize}
	\item $a_1a_2a_3\dots$ is a trace.
	\end{itemize}
\end{block}

\end{small}
\end{frame}



\begin{frame}{Traces for Trees}
\begin{footnotesize}


$\p$ sends and $\q$ receives:
\[
\begin{tikzcd}[ampersand replacement=\&]
\dcog {\comsgn \p \q \ell(S). \coG} \arrow[rr, "\text{step}_1"]\& \& 
\dcog {\comsgs \p \q \ell\ell(S). \coG}\arrow[rr, "\text{step}_2"]
\& \&\coG
\end{tikzcd}
\]

%\[
%\begin{tikzcd}[ampersand replacement=\&]
%\comsgn \p\q \dcog{\ell (S).} \coG \arrow[rr, "\text{step}_1 "]\arrow[dd,"\upharpoonright_{\p}"]
%\& \&
%\comsgs \p\q \ell \dcog{\ell (S).} {\coG}\arrow[rr, "\text{step}_2 "]\arrow[rrdd, "\upharpoonright_{\p}"]
%\& \&
%\coG\arrow[dd, "\upharpoonright_{\p}"] \\
%\& \& \& \&\\
%\colsnd \q \dcol{\ell (S).} \colT \arrow[rrrr, "\text{step}_1"]\& \& \& \&\colT
%\\
%\comsgn \p\q \dcog{\ell (S).} {\coG} \arrow[rr, "\text{step}_1 "]\arrow[dd,"\upharpoonright_{\q}"]
%\& \&
%\comsgs \p\q {\ell} \dcog{\ell (S).} {\coG}\arrow[rr, "\text{step}_2 "]\arrow[lldd, "\upharpoonright_{\q}"]
%\& \&
%\coG\arrow[dd, "\upharpoonright_{\q}"] \\
%\& \& \& \&\\
%\colrcv \p \dcol{\ell (S).} \colT\dcol{'} \arrow[rrrr, "\text{step}_2"]\& \& \& \&\colT\dcol{'}
%\end{tikzcd}
%\]
\  \\

Let $t$ be a trace for $\coG$, %\textbf{and} $\dcol{E}$, where $\dcol{E(\p)=\colT}$ and $\dcol{E(\q)=\colT\dcol{'}}$
\[
\begin{tikzcd}[ampersand replacement=\&]
\p\q ! (\ell,S)\p\q ? (\ell,S)t\& \&\p\q ? (\ell,S)t\arrow[ll, "\text{step}_1"]\& \&t\arrow[ll, "\text{step}_2"]
\end{tikzcd}
\]
\end{footnotesize}
\end{frame}


\begin{frame}{Non-Determinism}
\begin{small}
Let us consider two different executions:
\begin{itemize}
	\item $
\comsgni \p\q \ell {S} {\coG}\stepa{\ell_1}\comsgsi \p\q {\ell_1}  \ell {S} {\coG}\stepa{\ell_1}\coG_{\color{pine}1}
$
	\item $
\comsgni \p\q \ell {S} {\coG}\stepa{\ell_2}\comsgsi \p\q {\ell_2}  \ell {S} {\coG}\stepa{\ell_2}\coG_{\color{pine}2}
$
\end{itemize}

\ \\
If $t_1$ is a trace admissible for $\coG_{\color{pine}1}$ and $t_2$ is admissible for $\coG_{\color{pine}2}$, both 
\begin{itemize}
\item $\p\q ! (\ell_1,S_1)\p\q ? (\ell_1,S_1)t_1$ and
\item $\p\q ! (\ell_2,S_2)\p\q ? (\ell_2,S_2)t_2$
\end{itemize}
 are admissible for  $\comsgni \p\q \ell {S} {\coG}$.

\end{small}
\end{frame}

\begin{frame}{Trace Equivalence}
%\begin{theorem}[Step Soundness]
%If $\coG\upharpoonright\!\upharpoonright({\color{dkolive}E},Q)$ and $\coG\Rightarrow\coG{\color{pine}'}$, then there exist ${\color{dkolive}E'}$ and $Q'$, such that $\coG{\color{pine}'}\upharpoonright\!\upharpoonright({\color{dkolive}E'},Q')$ and $({\color{dkolive}E},Q)\Rightarrow({\color{dkolive}E'},Q')$.
%\end{theorem}
%
%\begin{theorem}[Step Completeness]
%If $\coG\upharpoonright\!\upharpoonright({\color{dkolive}E},Q)$ and $({\color{dkolive}E},Q)\Rightarrow({\color{dkolive}E},Q)$, then there exists $\coG{\color{pine}'}$, such that  $\coG{\color{pine}'}\upharpoonright\!\upharpoonright({\color{dkolive}E'},Q')$ and $\coG\Rightarrow\coG{\color{pine}'}$.
%\end{theorem}

%\visible<2->{
And finally...%}

%\visible<3->{
\visible<2->{
\begin{theorem}[Trace Equivalence]
If $\coG\upharpoonright^{\sf c}{\color{dkolive}E}$ %$\coG\upharpoonright\!\upharpoonright({\color{dkolive}E},Q)$ 
then the set of traces admissible for $\coG$ is equal to the set of traces admissible for ${\color{dkolive}E}$.
%$({\color{dkolive}E},Q)$.
\end{theorem}
}
%}
\end{frame}

\begin{frame}[fragile]{Certifying the Semantics of Communication}

\[
\begin{tikzcd}
\G\arrow[rr, "\rho"]\arrow[dd, "{\pmb \upharpoonright}"]& &\coG\arrow[rr, "\text{LTS}"]\arrow[dd, "{\pmb \upharpoonright}^{\sf c}" black] & & \text{Traces}\arrow[dd, leftrightarrow, "="]\\
& &\\
\lT\arrow[rr, "\rho_L"]& &\colT\arrow[rr, "\text{LTS}"]& &\text{Traces}
\end{tikzcd}
\]

\begin{itemize}
\item Multiparty Session Types \checkmark
\item Coinductive Trees (equi-recursive point of view) \checkmark
\item Semantics by Traces \checkmark (almost)
\end{itemize}

\end{frame}




\begin{frame}{Things We Used}
\begin{small}
Formalisation in the Coq\footnote{\tiny https://coq.inria.fr/} Proof Assistant, in particular we have used:
\begin{itemize}
\item the SSReflect\footnote{\tiny https://coq.inria.fr/refman/proof-engine/ssreflect-proof-language.html} proof language;
\item the Mathematical Components\footnote{\tiny https://math-comp.github.io/} libraries;
\item the PaCo library for parametrized coinduction\footnote{\tiny https://github.com/snu-sf/paco}.
\end{itemize}
\end{small}
\end{frame}

\begin{frame}{Conclusion}
\begin{footnotesize}

\begin{block}{Things we have got:}
\begin{itemize}
	\item a formalisation of the metatheory of mutliparty session types in Coq%, with MathComp, PaCo and SSReflect
	\item two birds with a (coinductive) stone: equi-recursion and no bindings
	\item (non-deterministic) semantics through labelled transition systems
    \item types that are ready for typing! \visible<2->{\textcolor{dkred}{Please attend Francisco's talk! :) }}
\end{itemize}
\end{block}
\begin{block}{From here what?}
\begin{itemize}
	\item a more comprehensive version of MPST (e.g., with merge operator)
	\item communicating finite state automata
	\item ... the future is unwritten!
\end{itemize}
\end{block}
\begin{center}
\visible<2->{\textcolor{dkred}{Thank You!}}
\end{center}


\end{footnotesize}

\end{frame}








\end{document}\grid
