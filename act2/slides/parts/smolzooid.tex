\section{Smol Zooid}

\subsection{Processes}

\begin{frame}
    \frametitle{Goals}
    \begin{sticky}%
    \vspace{-.7cm}
    \begin{enumerate}
    \item Certifying \textbf{individual} processes of a \textbf{distributed system}
    \item Extracting runnable code
    \item Avoiding complex formalisations of binders, whenever possible
    \end{enumerate}
    \end{sticky}
\end{frame}

\pgfdeclarelayer{background}
\pgfsetlayers{background,main}
\begin{frame}
    \frametitle{Overview}

  \centering
  \begin{tikzpicture}[commutative diagrams/every diagram]
    \begin{pgfonlayer}{background}
      \fill[rounded corners, yellow!20!white] (-0.8,0.5) rectangle (7.5,-3.5);
    \end{pgfonlayer}
    
    \node(G0)at (0,0) {$\G$};
    \node(G1)at (3,0) {$\coG$};
    \node(G2)at (6,0) {\small{global trace}};
    \node(L0)at (0,-1.5) {$\lT$};
    \node(L1)at (3,-1.5) {$\colT$};
    \node(L2)at (6,-1.5) {\small{local trace}};
    \node(P0)at (0,-3) {$\proc$};
    \node(P2)at (6,-3) {\small{process trace}};
    \node(OC)at (0,-5) {\small{OCaml code}};
    \node(ZZ)at (3.5,-5) {\bf \dslName};
     
     \path[commutative diagrams/.cd,every arrow,font=\scriptsize]
     (G0) edge node[above] {$\Re$} (G1)
     (G1) edge node[above] {LTS} (G2)
     (L0) edge node[above] {$\Re$} (L1)
     (L1) edge node[above] {LTS} (L2)
     (G0) edge node[right] {$\upharpoonright$} (L0)
     (G1) edge node[right] {$\upharpoonright^{\textsf{c}}$} (L1)
     (G2) edge[<->] node[right] {$=$} (L2)
     (L0) edge node[right] {$\ofLt$} (P0)
     (P0) edge node[above, xshift=-.5cm] {LTS} (P2)
     (P2) edge node[right] {erase} (L2)
     (P0) edge node[left] {extraction} (OC)
     (P0) edge[<->] node[right,xshift=.1cm] {DSL layer} (ZZ)
     ;
%      \path[dashed, red, commutative diagrams/.cd, font=\scriptsize]
%      (L0) edge[bend left=40] node[below left,yshift=.4cm, xshift=-.2cm]
%        {Well typed!} (ZZ)
%      (P2) edge[] node[below right] {Certified semantics!} (ZZ)
%      (OC) edge[] node[above] {Extractable!} (ZZ)
%      ;
  \end{tikzpicture}

\end{frame}

\begin{frame}
    \frametitle{Smol Zooid}
    \begin{greenbox}{}
    \begin{itemize}
    \item We combine \textbf{shallow/deep embeddings} of binders
    \begin{itemize}
    \item We use DeBruijn indices for the deeply embedded binders
    \end{itemize}
    \item SZooid constructs are \textbf{well-typed by construction}
    \item We leverage \textbf{Coq code extraction} mechanism
    \item For simplicity, SZooid does not cover \emph{choices}
    \end{itemize}
    \end{greenbox}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Core Processes}
    In: \url{http://github.com/emtst/gentleAdventure}
\vspace{.5cm}
    \begin{minted}{coq}
Inductive proc :=
| Inact | Rec (e : proc) | Jump (X : nat)
| Send (p : participant) {T : type}
     (x : interp_type T) (k : proc)
| Recv (p : participant) {T : type}
    (k : interp_type T -> proc)

| ReadIO {T : type} (k : interp_type T -> proc)
| WriteIO {T : type} (x : interp_type T) (k : proc).
    \end{minted}    
\end{frame}

\begin{frame}[fragile]
    \frametitle{Payload Types}
    We need to define a type for payload types:
    \begin{itemize}
    \item We need a decidable equality on payload types
    \item We need a decidable equality on payload values
    \end{itemize}
\vspace{1cm}
    \begin{minted}{coq}
Inductive type := Nat | Bool | ...
Definition interp_type : type -> Type := ...
    \end{minted}
\end{frame}

\subsection{Traces}


\begin{frame}[fragile]
    \frametitle{Semantics: events}
    The semantics is an LTS: 
    \begin{itemize}
    \item the labels are the \textbf{communication events}
    \item it is parameterised by a \textbf{payload interpretation function}
    \item traces are obtained as the greatest fixpoint of the LTS step
    \end{itemize}
\vspace{.5cm}
    \begin{minted}{coq}
Inductive action := a_send | a_recv.
Record event interp_payload :=
  { action_type  : action;
    subj         : participant;
    party        : participant;
    payload_type : type;
    payload      : interp_payload payload_type
  }.
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Semantics: Recursion Variables and I/O}
    \verb|p_unroll : proc -> proc| 
\vspace{.2cm}

\verb|p_unroll| exposes the first communication action in a process:
\begin{itemize}
\item ``runs'' any I/O action
\item unfolds recursion
\end{itemize}
\vspace{1cm}
    \begin{minted}{coq}
Definition p_unroll : proc -> proc := ...
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Semantics: step}
The step of the LTS is defined as a \textbf{function}:
\vspace{.5cm}
    \begin{minted}{coq}
Definition step' e E :=
  match e with
  | Send p T x k =>
    if (action_type E == a_send) && (party E == p) &&
       (eq_payload (payload E) x)
    then Some k else None
  | Recv p T k => ...  | _ => None
  end.
Definition step e := step' (p_unroll e).
    \end{minted}
\end{frame}

\subsection{Local Types}

\begin{frame}[fragile]
    \frametitle{Local Types}
    We introduce a typing discipline that associates processes with \textbf{local types}, that 
characterise their communication behaviour:

    \begin{minted}{coq}
Inductive lty :=
  | l_end
  | l_jump (X : nat)
  | l_rec (k : lty)
  | l_send (p : participant) (T : type) (l : lty)
  | l_recv (p : participant) (T : type) (l : lty).
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Type System}
    \begin{minted}{coq}
Inductive of_lty : proc -> lty -> Prop :=
| lt_Send    p T k L x :
    of_lty k L -> of_lty (@Send p T x k) (l_send p T L)
| lt_ReadIO  T k L :
    (forall x, of_lty (k x) L) -> of_lty (@ReadIO T k) L
| ...
.
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Smol Zooid: Smart Constructors (I)}
    \begin{sticky}
\vspace{-.5cm}
    \begin{itemize}
        \item It would be tedious to type up both a local type and a process
        \item Users would need to provide a proof that processes are well-typed
    \end{itemize}
    \end{sticky}
    \begin{greenbox}{}
        We define \textbf{SZooid} (Smol Zooid), to write
well-typed processes by construction, avoiding repetition.
    \end{greenbox}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Smol Zooid: Smart Constructors (and II)}
\begin{minted}{coq}
Definition SZooid L := { p | of_lty p L}.

Definition z_Send  p T x L (k : SZooid L)
  : SZooid (l_send p T L)
  := exist _ _ (lt_Send p x (proj2_sig k)).
...
\end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Inferring Local Types}
    SZooid constructs fully determine their types from their inputs, so we can ask Coq to \emph{infer} local types
associated with SZooid terms:
\vspace{1cm}
\begin{minted}{coq}
Definition AZooid := { L & SZooid L }.
\end{minted}
\end{frame}

\subsection{Subject Reduction}

\begin{frame}[fragile]
\frametitle{Subject Reduction}
\begin{minted}{coq}
Theorem preservation (e : proc) (L : lty) 
    (H : of_lty e L) (E : rt_event) :
  forall e',
    step e E = Some e' ->
      exists L', lstep L (ev_erase E) = Some L' /\
                 of_lty e' L'.
\end{minted}
\end{frame}

\subsection{Extraction}

\begin{frame}[fragile]
\frametitle{Extraction}
\begin{itemize}
\item We convert \verb|proc| to function calls in an \textbf{ambient monad}
\item We extract the monadic code to OCaml
\item The ambient monad needs to be implemented in OCaml
\item Processes are extracted using Higher-Order modules, so it is straightforward to change the underlying
transport
\vspace{.2cm}
\item \textbf{Remark:} SZooid does not provide an implementation of the ambient monad, but Zooid does, using TCP/IP sockets: 
\url{https://github.com/emtst/zooid-cmpst}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Extraction Module}
\begin{minted}{coq}
Module ProcExtraction (MP : ProcessMonad).
  Fixpoint extract_proc (d : nat) (p : proc) : MP.t unit 
    := match p with
       | Send p T x k
         => MP.bind (MP.send T p x)
                    (fun=> extract_proc d k)
       ...
End ProcExtraction.
\end{minted}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example Extraction}
\begin{minted}{coq}
Module  ALICE (MP : ProcessMonad) : PROCESS(MP).
  Module PE := ProcExtraction(MP).
  Definition proc :=
    Eval compute in PE.extract_proc 0 alice.
End ALICE.

Extraction ALICE.
\end{minted}
\end{frame}

\begin{frame}[fragile]
\frametitle{Summary}
\begin{sticky}
\begin{itemize}
\item We have seen how to encode a small calculus of Multiparty Processes, with a basic type system
\item \textbf{Next: how do we relate traces of individual processes to a larger system?}
\end{itemize}
\end{sticky}
\end{frame}
