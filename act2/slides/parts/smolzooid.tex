\section{Smol Zooid}

\subsection{Processes}

\begin{frame}
    \frametitle{Goals}
    \begin{sticky}%
    \vspace{-.7cm}
    \begin{enumerate}
    \item Certifying \textbf{individual} processes of a \textbf{distributed system}
    \item Extracting runnable code
    \item Avoiding complex formalisations of binders, whenever possible
    \end{enumerate}
    \end{sticky}
\end{frame}

\pgfdeclarelayer{background}
\pgfsetlayers{background,main}
\begin{frame}
    \frametitle{Overview}

  \centering
  \begin{tikzpicture}[commutative diagrams/every diagram]
    \node(G0)at (0,0) {$\G$};
    \node(G1)at (3,0) {$\coG$};
    \node(G2)at (6,0) {\small{global trace}};
    \node(L0)at (0,-1.5) {$\lT$};
    \node(L1)at (3,-1.5) {$\colT$};
    \node(L2)at (6,-1.5) {\small{local trace}};
    \node(P0)at (0,-3) {$\proc$};
    \node(P2)at (6,-3) {\small{process trace}};
    \node(OC)at (0,-5) {\small{OCaml code}};
    \node(ZZ)at (3.5,-5) {\bf \dslName};
     
     \path[commutative diagrams/.cd,every arrow,font=\scriptsize]
     (G0) edge node[above] {$\Re$} (G1)
     (G1) edge node[above] {LTS} (G2)
     (L0) edge node[above] {$\Re$} (L1)
     (L1) edge node[above] {LTS} (L2)
     (G0) edge node[right] {$\upharpoonright$} (L0)
     (G1) edge node[right] {$\upharpoonright^{\textsf{c}}$} (L1)
     (G2) edge[<->] node[right] {$=$} (L2)
     (L0) edge node[right] {$\ofLt$} (P0)
     (P0) edge node[above, xshift=-.5cm] {LTS} (P2)
     (P2) edge node[right] {erase} (L2)
     (P0) edge node[left] {extraction} (OC)
     (P0) edge[<->] node[right,xshift=.1cm] {DSL layer} (ZZ)
     ;
%      \path[dashed, red, commutative diagrams/.cd, font=\scriptsize]
%      (L0) edge[bend left=40] node[below left,yshift=.4cm, xshift=-.2cm]
%        {Well typed!} (ZZ)
%      (P2) edge[] node[below right] {Certified semantics!} (ZZ)
%      (OC) edge[] node[above] {Extractable!} (ZZ)
%      ;
    \begin{pgfonlayer}{background}
	    % We cheat a bit here: the green part is actually not transparent, 
	    % which allows us to "merge" both rectangles, the consequence is 
	    % that it has to be drawn first.
	    \node[rounded corners, rectangle, green!20!white, fill, fit=(P2)(OC), text=green] {};
	    \node[rounded corners, rectangle, green!20!white, fill, fit=(P0)(L0), text=green] {};
	    \fill[rounded corners, yellow, opacity=0.2] (-0.8,0.5) rectangle (7.5,-3.5);
	    \node[rounded corners, rectangle, red, opacity=0.2, fill, fit=(G0)(L2), text=red] {Act 3};
    \end{pgfonlayer}
    
  \end{tikzpicture}

\end{frame}

\begin{frame}
    \frametitle{Smol Zooid}
    \begin{greenbox}{}
    \begin{itemize}
    \item We combine \textbf{shallow/deep embeddings} of binders
    \begin{itemize}
    \item Processes are defined inductively
    \item Values are standard Gallina values
    \item We use DeBruijn indices for the deeply embedded binders
    \end{itemize}
    \item SZooid constructs are \textbf{well-typed by construction}
    \end{itemize}
    \end{greenbox}
    \begin{greenbox}{}
    \begin{itemize}
    \item We leverage \textbf{Coq code extraction} mechanism
    \item For simplicity, SZooid does not cover \emph{choices}
    \end{itemize}
    \end{greenbox}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Core Processes}
    In: \url{http://github.com/emtst/gentleAdventure}
\vspace{.5cm}
    \begin{minted}{coq}
Inductive proc :=
| Inact | Rec (e : proc) | Jump (X : nat)
| Send (p : participant) {T : type}
     (x : interp_type T) (k : proc)
| Recv (p : participant) {T : type}
    (k : interp_type T -> proc).
    \end{minted}    
\end{frame}

\begin{frame}[fragile]
    \frametitle{Payload Types}
    We need to define a type for payload types:
    \begin{itemize}
    \item We need a decidable equality on payload types
    \item We need a decidable equality on payload values
    \end{itemize}
\vspace{1cm}
    \begin{minted}{coq}
Inductive type := Nat | Bool | ...
Definition interp_type : type -> Type := ...
    \end{minted}
\end{frame}

\subsection{Traces}

\begin{frame}{Semantics: overview}
	\[P\xrightarrow{E} P^\prime\]
	\vspace{1cm}
	\begin{itemize}
		\item What is an event?
		\item How to manage recursion?
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Semantics: events}
    The semantics is an LTS: 
    \begin{itemize}
    \item the labels are the \textbf{communication events}
    \item it is parameterised by a \textbf{payload interpretation function}
    \item traces are obtained as the greatest fixpoint of the LTS step
    \end{itemize}
\vspace{.5cm}
    \begin{minted}{coq}
Inductive action := a_send | a_recv.
Record event interp_payload :=
  { action_type  : action;
    subj         : participant;
    party        : participant;
    payload_type : type;
    payload      : interp_payload payload_type }.
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Semantics: Recursion Variables}
\verb|p_unroll| exposes the first communication action in a process (unfold recursion):
\vspace{1cm}
    \begin{minted}{coq}
Definition p_unroll e := 
match e with
| Rec e' => p_subst 0 e e'
| e' => e'
end.
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Semantics: Recursion Variables}
	\begin{minted}{coq}
Fixpoint p_subst d e' e :=
match e with
| Rec e => Rec (p_subst d.+1 e' e)
| Jump X => if X == d then p_shift d 0 e' else e
| ...
end.

Example ex_p_subst:
p_subst 0 (ping_Alice) (Rec (Jump 1)) = Rec ping_Alice.
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Semantics: recursion unrolling}
	\begin{minted}{coq}
(* unroll uT. Alice!0. T to Alice!0. uT. Alice!0. T *)
Example ex_p_unroll:
p_unroll (Rec (@Send Alice Nat 0 (Jump 0)))
= @Send Alice Nat 0 (Rec (@Send Alice Nat 0 (Jump 0))).
	\end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Semantics: step}
The step of the LTS is defined as a \textbf{function}:
\vspace{.5cm}
    \begin{minted}{coq}
Definition step' e E :=
  match e with
  | Send p T x k =>
    if (action_type E == a_send) && (party E == p) &&
       (eq_payload (payload E) x)
    then Some k else None
  | Recv p T k => ...  | _ => None
  end.
Definition step e := step' (p_unroll e).
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Semantics: step}
	\begin{minted}{coq}
Definition event_alice: event interp_type := 
{| action_type := a_send;
   from := Bob;
   to := Alice;
   payload_type := Nat;
   payload := 0 |}.
Example ex_step: step infinite_ping_Alice event_alice
		= Some infinite_ping_Alice.
	\end{minted}
\end{frame}

\subsection{Local Types}
\begin{frame}{Local Types}
	\begin{itemize}
		\item Local types for processes
		\item Notion of ``Being well-typed''
		\item Simultaneous construction of processes \& well-typeness proof
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Local Types}
    \begin{minted}{coq}
Inductive lty :=
  | l_end
  | l_jump (X : nat)
  | l_rec (k : lty)
  | l_send (p : participant) (T : type) (l : lty)
  | l_recv (p : participant) (T : type) (l : lty).
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Type System}
    \begin{minted}{coq}
Inductive of_lty : proc -> lty -> Prop :=
| lt_Send    p T k L x :
    of_lty k L -> of_lty (@Send p T x k) (l_send p T L)
| ...
.

Example ex_of_lty:
of_lty infinite_ping_Alice
(l_rec (l_send Alice Nat (l_jump 0))).
    \end{minted}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Smol Zooid: Smart Constructors}
    \begin{sticky}
\vspace{-.5cm}
    \begin{itemize}
        \item It would be tedious to type up both a local type and a process
        \item Users would need to provide a proof that processes are well-typed
    \end{itemize}
    \end{sticky}
    \begin{greenbox}{}
        We define \textbf{SZooid} (Smol Zooid), to write
well-typed processes by construction, avoiding repetition.
    \end{greenbox}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Smol Zooid: Smart Constructors}
\begin{minted}{coq}
Definition SZooid L := { p | of_lty p L}.

Definition z_Send  p T x L (k : SZooid L)
  : SZooid (l_send p T L)
  := exist _ _ (lt_Send p x (proj2_sig k)).
...
\end{minted}
\end{frame}

\begin{frame}[fragile]{Smol Zooid: Smart Constructors}
\begin{minted}{coq}
Example Alice_smart_constructor :=
	z_Rec (z_Send Bob Nat 42 (z_Jump 0)).
(*
Alice_smart_constructor:
	SZooid (l_rec (l_send Bob Nat (l_jump 0)))
*)
\end{minted}
\end{frame}


\begin{frame}{Conclusion}
	\begin{enumerate}
		\item Define processes and local types
		\item Semantics of processes
		\item Automatic construction of local types
	\end{enumerate}
	\begin{itemize}
		\item We also have {\it code extraction}
		\item and {\it subject reduction}
	\end{itemize}
\end{frame}


\begin{frame}[fragile]
    \frametitle{Automated well-typedness}
    SZooid constructs fully determine their types from their inputs, so we can
    ask Coq to derive local types associated with SZooid terms:
\vspace{1cm}
\begin{minted}{coq}
Definition AZooid := { L & SZooid L }.
\end{minted}
\end{frame}

\subsection{Subject Reduction}

\begin{frame}[fragile, noframenumbering]
\frametitle{Subject Reduction}
\begin{minted}{coq}
Theorem preservation (e : proc) (L : lty) 
    (H : of_lty e L) (E : rt_event) :
  forall e',
    step e E = Some e' ->
      exists L', lstep L (ev_erase E) = Some L' /\
                 of_lty e' L'.
\end{minted}
\end{frame}

\subsection{Extraction}

\begin{frame}[fragile, noframenumbering]
\frametitle{Extraction}
\begin{itemize}
\item We convert \verb|proc| to function calls in an \textbf{ambient monad}
\item We extract the monadic code to OCaml
\item The ambient monad needs to be implemented in OCaml
\item Processes are extracted using Higher-Order modules, so it is straightforward to change the underlying
transport
\vspace{.2cm}
\item \textbf{Remark:} SZooid does not provide an implementation of the ambient monad, but Zooid does, using TCP/IP sockets: 
\url{https://github.com/emtst/zooid-cmpst}
\end{itemize}
\end{frame}

\begin{frame}[fragile, noframenumbering]
\frametitle{Extraction Module}
\begin{minted}{coq}
Module ProcExtraction (MP : ProcessMonad).
  Fixpoint extract_proc (d : nat) (p : proc) : MP.t unit 
    := match p with
       | Send p T x k
         => MP.bind (MP.send T p x)
                    (fun=> extract_proc d k)
       ...
End ProcExtraction.
\end{minted}
\end{frame}

\begin{frame}[fragile, noframenumbering]
\frametitle{Example Extraction}
\begin{minted}{coq}
Module  ALICE (MP : ProcessMonad) : PROCESS(MP).
  Module PE := ProcExtraction(MP).
  Definition proc :=
    Eval compute in PE.extract_proc 0 alice.
End ALICE.

Extraction ALICE.
\end{minted}
\end{frame}

\begin{frame}[fragile, noframenumbering]
\frametitle{Summary}
\begin{sticky}
\begin{itemize}
\item We have seen how to encode a small calculus of Multiparty Processes, with a basic type system
\item \textbf{Next: how do we relate traces of individual processes to a larger system?}
\end{itemize}
\end{sticky}
\end{frame}
